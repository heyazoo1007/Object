## 9장

의존성 최소화하는 방법, 생성과 사용 분리, 의존성 해결

### 개방-폐쇄 원칙(OCP, Open-Closed Principle)

소프트웨어 개체(클래스, 모듈, 함수 등) 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다

### 의존성 관점에서 개방-폐쇄 원칙을 따르는 설계

컴파일타임 의존성은 유지하면서, 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조.

변하지 않는 부분은 **추상 클래스**로,

변하는 부분은 **상속 클래스**로 표현

- 컴파일타임 의존성을 고정 시킴으로써 변경에 닫혀있을 수 있고
- 런타임 의존성을 변경시킴으로써 확장에 열려있을 수 있다.

- 변하지 않는 부분이 추상화 되었으므로, 변경에 대해 폐쇄적이고
- 변하는 부분은 상속 클래스이므로, 다른 자식 클래스를 추가할 수 있으므로 확장에 대해서는 열려있다

### 생성과 사용 분리하기

하나의 객체에서 생성과 사용의 책임을 각각 분리해야 유연하고 재사용 가능한 설계가 가능하다

→ 객체를 생성할 책임을 클라이언트로 옮기는 것이 보편적인 방법

### Factory

생성과 사용을 분리하기 위해 객체 생성에 특화된 객체를 말한다

객체를 분해하는 방법

- 표현적 분해: 도메인에 존재하는 사물 또는 객체로 시스템을 분해하는 것
- 행위적 분해

도메인에 있지 않지만 애플리케이션의 기능적 품질 향상을 위해 기능적인 객체를 추가해야하는 경우가 생긴다.

모든 책임을 도메인 객체에게 할당하면 낮은 응집도, 높은 결합도, 재사용성 저하 같은 문제가 발생

→ 도메인과는 무관하지만, 기능 향상을 위해 ‘순수한 가공물' 객체가 필요하다

### Pure Fabrication(순수한 가공물)

책임을 할당하기 위해 창조되는 (도메인과 무관한) 인공적인 객체

Factory는 Pure Fabrication

---
### 의존성 해결

- 의존성 주입(Dependency Injection)
- Service Locator 패턴

### 의존성 주입

생성과 사용을 분리하면 사용의 책임을 가지고 있는 객체는 어떻게 생성된 인스턴스를 사용할 수 있나?

→ 외부의 다른 객체가 생성된 인스턴스를 전달해줘야 한다.

→ 전달해주는 방법은 의존성 주입을 이용!

**종류**

- 생성자 주입
- 수정자 주입
- 메서드 주입

**생성자 주입**

객체를 생성하는 시점에 생성자를 통해 의존성을 해결하는 방법

인스턴스가 객체의 생명주기 동안 관계가 유지된다

**setter(수정자) 주입**

장점: 의존성의 대상을 런타임에 변경할 수 있다는 것. 언제라도 의존대상을 교체할 수 있음

단점: 어떤 의존성이 필수적인지 명시적으로 알 수 없다.

**메서드 주입(의존성 주입으로 봐야하는 논란이 있음)**

메서드 실행 시 인자를 이용한 의존성을 해결하는 방법

메서드가 의존성을 필요로하는 때가 유일할 때 사용한다

### 의존성 역전 원칙(Dependency Inversion Principle,DIP)

1. 상위 수준의 모듈은 하위 수준의 모듈에 의존하면 안 된다. 둘 다 모두 추상화에 의존해야 한다
2. 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다

→ 구체클래스, 상위/하위 모듈은 *추상화*에 의존해야한다